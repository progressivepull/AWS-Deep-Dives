# 9.2 Understanding DynamoDB 
 
 # 📘 Understanding DynamoDB

_Amazon DynamoDB is a fully managed NoSQL database service designed for high performance and scalability._

---

## 🚀 Overview

> "It's a fast flexible NoSQL database service for single-digit millisecond performance at any scale." — AWS

- DynamoDB is a **managed NoSQL database** offering key-value and document data models.
- It abstracts infrastructure management, allowing users to focus solely on data and table interactions.
- Similar to RDS, AWS handles the backend engine while users interact with the service.

---

## 🛠️ Architecture and Consistency

- **Fault-tolerant design**: Distributed across multiple Availability Zones (AZs).
- **Read-after-write consistency issue**:
  - Data may be fresh in one AZ but stale in another immediately after a write.
  - DynamoDB offers two read types:
    - **Eventually consistent reads**
    - **Strongly consistent reads**

---

## 📈 Scalability and Performance

- Supports **scaling of provisioned read/write capacity** without downtime.
- **Auto scaling** is available to adjust capacity based on usage patterns.

---

## 🔐 Security and Access

- **Encryption in transit** is supported when connecting via VPC.
- **Time-to-live (TTL)** expiration can be configured for automatic data deletion.
- **No security groups**; access is managed entirely through **IAM policies**.
- Supports **identity-based access** via services like **Amazon Cognito** and **STS** for federated users.

---

## 🧱 Core Components

| Component     | Description                                                                 |
|---------------|-----------------------------------------------------------------------------|
| Table         | Collection of items                                                         |
| Item          | Analogous to a row in RDBMS; contains attributes and a primary key          |
| Attribute     | Describes the item; part of the primary key or additional metadata          |
| Primary Key   | Uniquely identifies each item                                               |

- **Naming rules**:
  - Allowed characters: ```A–Z, a–z, 0–9, _, -, . ```
  - Length: 1–255 characters
  - Case-sensitive
  - UTF-8 encoding
  # 🚫 Reserved Words in DynamoDB

Amazon DynamoDB reserves certain keywords that **cannot be used as attribute names** in expressions. These reserved words may cause syntax errors or unexpected behavior if used improperly in queries, updates, or filters.

As of now, **DynamoDB has 573 reserved words**. Developers should avoid using these words directly as attribute names unless they are escaped using expression attribute names (e.g., `#name`).

---

## 🔍 Why It Matters

When building queries or update expressions in DynamoDB, using reserved words without escaping them can lead to:

- ❌ Syntax errors
- ❌ Failed requests
- ❌ Unexpected behavior in data operations

To avoid this, always refer to the official list and use expression attribute names when necessary.

---

## 📋 Sample Reserved Words

Below is a sample of reserved words grouped by initial keyword:

| ABORT     | ABSOLUTE | ACTION    | ADD     | AFTER     |
|-----------|----------|-----------|---------|-----------|
| AGENT     | ALL      | ALLOCATE  | ALTER   | ANALYZE   |
| AND       | ANY      | ARCHIVE   | ARE     | ARRAY     |
| AS        | ASC      | ASCII     | AT      | ATOMIC    |

> 🔗 Full list available at: [AWS DynamoDB Reserved Words](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)

---

## ✅ Best Practices

- Use **expression attribute names** to safely reference reserved words:
  ```javascript
  ExpressionAttributeNames: {
    "#action": "ACTION"
  }
```
* Validate attribute names against the reserved word list before deploying schema changes.
* Automate checks in CI/CD pipelines to catch reserved word usage early.

## 🛠️ Example: Safe Update Expression

``` javascript
UpdateExpression: "SET #action = :newValue",
ExpressionAttributeNames: {
  "#action": "ACTION"
},
ExpressionAttributeValues: {
  ":newValue": "archive"
}

```
## 📚 Additional Resources

* [DynamoDB Developer Guide](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Introduction.html)

* [Working with Expressions](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.html)


---

## 🧑‍💻 Access Methods

- **AWS Web Console**
- **AWS CLI**
- **SDKs** for programmatic access (e.g., Node.js, Python, Java)

---

## 📊 Monitoring and Metrics

- Metrics available via **CloudWatch** and the **DynamoDB console**:
  - Data input/output
  - Read/write capacity usage
  - Total item count
  - Table size

---

## 🧪 Demo: Creating a Table

1. Navigate to **DynamoDB > Tables** in the AWS Console.
2. Create a table named `SingleKey`.
3. Set `full_name` as the **partition key**.
4. Use **default settings**:
   - Capacity mode: **Provisioned**
   - Auto scaling: **Enabled**
   - No secondary indexes
   - No tags
5. Table creation takes ~6–7 seconds.
6. Post-creation:
   - View metrics under **Monitor**
   - Indexes under **Indexes tab**

---

## 🧠 Key Takeaways

- DynamoDB simplifies NoSQL database management with built-in scalability and fault tolerance.
- IAM governs all access; no security groups are used.
- Schema design decisions (e.g., secondary indexes) must be made at table creation.
- Monitoring and scaling are integral to maintaining performance and cost-efficiency.

---

_Use this guide to confidently deploy and manage DynamoDB tables in your AWS environment._

# 📘 Deep Dive into DynamoDB: Tables, Keys, Streams, and SDK Integration

This guide explores advanced DynamoDB concepts including global tables, backups, streams, key design, and SDK-based automation.

---

## 🌍 Global Tables

Global tables enable **cross-region replication** for high availability and disaster recovery.

### 🔄 Global Table Architecture

```text
+-------------------+       +-------------------+
| Region A (US-East)| <---> | Region B (EU-West)|
|   Table: Users    |       |   Table: Users    |
+-------------------+       +-------------------+
        ↑                           ↑
        |                           |
   Synchronous Replication Across Regions
```
* Replication is **synchronous** and **conflict-free**.

Ideal for multi-region applications with low-latency requirements.

# 💾 Backups, Exports, and Streams
* **Backups**: On-demand and automated backups available.
* **Exports**: Export table data to S3 for analytics or archiving.
* **Streams**: Capture item-level changes in real time.

# 🔁 DynamoDB Streams Workflow

```text
+-------------+       +------------------+       +------------------+
| DynamoDB    | --->  | DynamoDB Stream  | --->  | AWS Lambda       |
| Table       |       | (New & Old Image)|       | (Trigger Handler)|
+-------------+       +------------------+       +------------------+
```
* Use **Lambda triggers** to process changes (e.g., notify, transform, replicate).

* Stream records include **new and old images** of modified items.

# 📊 Provisioned Capacity (vs On-Demand)
This example uses provisioned capacity:

| Metric              | Value       |
|---------------------|-------------|
| Read Capacity Units | 5           |
| Write Capacity Units| 5           |
| Auto Scaling        | Enabled     |
| Mode                | Provisioned |


* **On-Demand** mode is not used in this example.
* Provisioned mode requires manual or auto-scaling configuration.

# 🧱 Key Design: Single vs Composite
## 🔑 Single Key Table
* **Table**: SingleKey
* **Primary Key**: full_name

```text
+------------------+--------+
| full_name        | age    |
+------------------+--------+
| Nick Garner      | 30     |
+------------------+--------+

```
❌ Cannot insert duplicate full_name values — poor schema for real-world use.

## 🔑 Composite Key Table
* **Table**: CompKey
* **Partition Key**: id
* **Sort Key**: full_name

```text
+-----+-------------+
| id  | full_name   |
+-----+-------------+
| 1   | Nick Garner |
| 2   | Nick Garner |
| 1   | John Smith  |
+-----+-------------+

```
✅ Allows overlapping partition or sort keys, but not both.

# 🧑‍💻 Node.js SDK Integration
## 📁 Project Structure

```text
DynamoDB/
├── app.js
├── cars.json
├── config.json
├── package.json
└── deleteTable.js
```
⚙️ app.js Workflow

1. Load AWS credentials from config.json
2. Create DynamoDB and docClient objects
3. Read data from cars.json
4. Create table: carsNE1
5. Wait for table to become active
6. Insert items using docClient.put()

## 📊 Table Parameters

| Parameter       | Value     |
|----------------|-----------|
| Table Name      | carsNE1   |
| Partition Key   | car_id    |
| Sort Key        | None      |
| Read Capacity   | 5         |
| Write Capacity  | 5         |

* Table creation takes ~6 seconds.
* 10 items loaded from cars.json.

## 🧠 Summary
| Feature              | Notes                                               |
|----------------------|-----------------------------------------------------|
| Global Tables        | Cross-region replication                            |
| Streams & Lambda     | Real-time triggers on item changes                  |
| Provisioned Capacity | Manual or auto-scaling of read/write throughput     |
| Single Key Table     | Limited uniqueness, poor schema for common use cases|
| Composite Key Table  | Flexible, avoids key collisions                     |
| Node.js SDK          | Automates table creation and data loading           |

 
 ## [Context](./../context.md)