# 12.8 Using SQS best practices 
 
 # Amazon SQS Best Practices

## Overview
Amazon Simple Queue Service (SQS) is a highly reliable and scalable messaging service, but proper configuration and usage are critical for efficiency, reliability, and cost control. The following best practices focus on message processing, error handling, and queue configuration.

---

## Tune the Visibility Timeout

- The default visibility timeout is **30 seconds**
- Set the visibility timeout based on:
  - Actual message processing time
  - Time required to delete the message
  - An additional safety buffer

**Recommended formula:**


Visibility Timeout = Processing Time + Delete Time + Buffer



If processing takes longer than the visibility timeout:
- The message may become visible again
- Another consumer may process the same message
- This can lead to duplicate processing

---

## Use SDKs with Retry and Exponential Backoff

- Always use **AWS SDKs** instead of calling service APIs directly
- SDKs include **built-in exponential backoff** for retryable errors
- This is a best practice across AWS services, not just SQS

### Example Use Case
- DynamoDB provisioned capacity limits can trigger throttling errors
- SDKs automatically:
  - Slow down requests
  - Retry with increasing delays
- Direct API calls without backoff can overwhelm services and cause failures

---

## Enable Long Polling

- Long polling waits for messages instead of returning empty responses
- Maximum wait time: **20 seconds**

### Benefits
- Fewer empty responses
- Reduced API calls
- Lower cost
- More efficient consumers

Long polling keeps the connection open until:
- A message arrives, or
- The wait time expires

---

## Use Redrive Policies and Dead-Letter Queues (DLQs)

- Redrive policies help **troubleshoot failed message processing**
- If a message cannot be processed:
  - It is retried
  - Eventually sent to a **dead-letter queue**

### Important Guidelines
- **Do not delete a message unless it is successfully processed**
- Avoid assuming success in your code
- Failed messages must remain in the queue until properly handled

---

## Special Consideration: SQS with AWS Lambda

- When SQS triggers a Lambda function:
  - Messages are **automatically deleted** after successful invocation
  - Failed messages are **not returned to the queue**
- It is the Lambda functionâ€™s responsibility to:
  - Handle failures
  - Log or route errors appropriately

---

## Configure Maximum Receives Carefully

- Avoid setting **Maximum Receives = 1** when using a DLQ
- If set to one:
  - Messages will never reach the dead-letter queue
  - They are discarded before redrive can occur

---

## Key Takeaways

- Tune visibility timeout based on real processing time
- Always use SDKs for built-in retry and exponential backoff
- Enable long polling for better efficiency and lower cost
- Use redrive policies and DLQs for failure handling
- Never delete messages unless processing succeeds
- Be cautious with Lambda-triggered SQS behavior
- Configure maximum receives to allow proper redrive to DLQs

Following these best practices ensures reliable, scalable, and cost-effective use of Amazon SQS.

 
 ## [Context](./../context.md)